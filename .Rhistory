dim(mm)
mm <- Matrix::t(methods::as(methods::as(adata$X, 'CsparseMatrix'), 'dgCMatrix'))
colnames(mm) <- adata$obs_names
rownames(mm) <- adata$var_names
head(mm)
adata$var
adata$obs
library(SimBu)
counts_file <- tempfile(pattern = 'test',fileext = '.h5ad')
url <- "https://seurat.nygenome.org/pbmc3k_final.h5ad"
curl::curl_download(url, counts_file)
gc()
devtools::document()
library(SimBu)
counts_file <- tempfile(pattern = 'test',fileext = '.h5ad')
url <- "https://seurat.nygenome.org/pbmc3k_final.h5ad"
curl::curl_download(url, counts_file)
ds <- dataset_h5ad(h5ad_file_counts = counts_file,
cell_id_col = 0, # this will us the rownames as cell identifiers,
cell_type_col = 'leiden')
h5ad_file_counts <- counts_file
h5ad_file_counts <- normalizePath(h5ad_file_counts)
file_type <- tools::file_ext(h5ad_file_counts)
h5ad_data <- h5ad_to_adata(h5ad_file_counts)
#' Use basilisk environment to read h5ad file and access anndata object
#'
#' @param h5ad_path path to h5ad file
#'
#' @return matrix contained on h5ad file as dgCMatrix
#'
h5ad_to_adata <- function(h5ad_path){
h5ad_path<-normalizePath(h5ad_path)
# create conda environment with anndata
proc <- basilisk::basiliskStart(SimBu_env)
on.exit(basilisk::basiliskStop(proc))
tryCatch({
# initialize environment
h5ad_data <- basilisk::basiliskRun(proc, function(){
sp <- reticulate::import("scanpy")
adata <- sp$read_h5ad(h5ad_path)
mm <- Matrix::t(methods::as(methods::as(adata$X, 'CsparseMatrix'), 'dgCMatrix'))
colnames(mm) <- adata$obs_names
rownames(mm) <- adata$var_names
return(list(mm=mm,
anno=adata$obs))
})
return(h5ad_data)
}, error=function(e){
message('Could not access h5ad file: ', h5ad_path)
return(NULL)
})
}
h5ad_data <- h5ad_to_adata(h5ad_file_counts)
# dependencies for sfaira and anndata0.7.6 (taken from zellkonverter package)
SimBu_env <- basilisk::BasiliskEnvironment(envname="SimBu_env",
pkgname="SimBu",
packages=c('python==3.9',
"anndata==0.7.6",
"h5py==3.2.1",
"hdf5==1.10.6",
"natsort==7.1.1",
"numpy==1.20.2",
"packaging==20.9",
"pandas==1.2.4",
"scipy==1.6.3",
"sqlite==3.35.5"),
pip = c('sfaira==0.3.12',
'tables==3.7.0')
)
h5ad_data <- h5ad_to_adata(h5ad_file_counts)
counts_file <- '~/testing/pbmc3k_final.h5ad'
h5ad_file_counts <- normalizePath(counts_file)
h5ad_data <- h5ad_to_adata(h5ad_file_counts)
h5ad_path <- h5ad_file_counts
# create conda environment with anndata
proc <- basilisk::basiliskStart(SimBu_env)
# initialize environment
h5ad_data <- basilisk::basiliskRun(proc, function(){
sp <- reticulate::import("scanpy")
adata <- sp$read_h5ad(h5ad_path)
mm <- Matrix::t(methods::as(methods::as(adata$X, 'CsparseMatrix'), 'dgCMatrix'))
colnames(mm) <- adata$obs_names
rownames(mm) <- adata$var_names
return(list(mm=mm,
anno=adata$obs))
})
sp <- reticulate::import("scanpy")
adata <- sp$read_h5ad(h5ad_path)
mm <- Matrix::t(methods::as(methods::as(adata$X, 'CsparseMatrix'), 'dgCMatrix'))
dim(mm)
colnames(mm) <- adata$obs_names
rownames(mm) <- adata$var_names
adata$var_names
adata$obs_names
colnames(mm) <- adata$obs_names
rownames(mm) <- adata$var_names
adata$var
adata$var$gene_ids
length(adata$var$gene_ids)
length(adata$var_names)
c(adata$var_names)
(adata$var_names)
rownames(rownames(adata$var))
adata$var
x<-adata$var
View(x)
rownames(x)
rownames(mm) <- rownames(data.frame(adata$var))
dimnames(mm)
rownames(data.frame(adata$var))
x<-rownames(data.frame(adata$var))
colnames(mm) <- rownames(data.frame(adata$obs))
mm <- Matrix::t(methods::as(methods::as(adata$X, 'CsparseMatrix'), 'dgCMatrix'))
rownames(mm) <- rownames(data.frame(adata$var))
colnames(mm) <- rownames(data.frame(adata$obs))
sp <- reticulate::import("scanpy")
adata <- sp$read_h5ad(h5ad_path)
mm <- Matrix::t(methods::as(methods::as(adata$X, 'CsparseMatrix'), 'dgCMatrix'))
colnames(mm) <- rownames(data.frame(adata$obs))
rownames(mm) <- rownames(data.frame(adata$var))
library(SimBu)
ds <- dataset_h5ad(h5ad_file_counts = '~/testing/pbmc3k_final.h5ad',
cell_id_col = 0, # this will us the rownames as cell identifiers,
cell_type_col = 'leiden')
ds
library(SimBu)
devtools::document()
BiocCheck::BiocCheck()
library(anndata)
ts_h5 <- normalizePath('~/testing/testSubsample.h5ad')
sp_h5 <- normalizePath('~/testing/pbmc3k_final.h5ad')
ts_ad <- anndata::read_h5ad(ts_h5)
rcmdcheck::rcmdcheck(args = c("--no-manual"), error_on = "warning", check_dir = "check")
rcmdcheck::rcmdcheck(args = c("--no-manual",'--ignore-vignettes'), error_on = "warning", check_dir = "check")
rcmdcheck::rcmdcheck(args = c("--no-manual",'--ignore-vignettes'), build_args = c('--no-build-vignettes') error_on = "warning", check_dir = "check")
rcmdcheck::rcmdcheck(args = c("--no-manual",'--ignore-vignettes'), build_args = c('--no-build-vignettes'), error_on = "warning", check_dir = "check")
devtools::document()
rcmdcheck::rcmdcheck(args = c("--no-manual",'--ignore-vignettes'), build_args = c('--no-build-vignettes'), error_on = "warning", check_dir = "check")
library(SimBu)
library(ggplot2)
# example h5ad file, where cell type info is stored in `obs` layer
h5 <- system.file('extdata', 'anndata.h5ad', package='SimBu')
ds_h5ad <- SimBu::dataset_h5ad(h5ad_file_counts = normalizePath('inst/extdata/anndata.h5ad'),
name = "h5ad_dataset",
cell_id_col = 'ID',                  # this will use the 'ID' column of the metadata as cell identifiers
cell_type_col = 'cell_type',         # this will use the 'cell_type' column of the metadata as cell type info
cells_in_obs = TRUE)                 # in case your cell information is stored in the var layer, switch to FALSE
ds_h5ad <- SimBu::dataset_h5ad(h5ad_file_counts = h5,
name = "h5ad_dataset",
cell_id_col = 'ID',                  # this will use the 'ID' column of the metadata as cell identifiers
cell_type_col = 'cell_type',         # this will use the 'cell_type' column of the metadata as cell type info
cells_in_obs = TRUE)                 # in case your cell information is stored in the var layer, switch to FALSE
# example h5ad file, where cell type info is stored in `obs` layer
h5_rev <- system.file('extdata', 'anndata_rev.h5ad', package='SimBu')
ds_h5ad <- SimBu::dataset_h5ad(h5ad_file_counts = h5_rev,
name = "h5ad_dataset",
cell_id_col = 'ID',                  # this will use the 'ID' column of the metadata as cell identifiers
cell_type_col = 'cell_type',         # this will use the 'cell_type' column of the metadata as cell type info
cells_in_obs = FALSE)                 # in case your cell information is stored in the var layer, switch to FALSE
library(Seurat)
library(curl)
library(SimBu)
counts <- Matrix::Matrix(matrix(rpois(3e5, 5), ncol=300), sparse = TRUE)
tpm <- Matrix::Matrix(matrix(rpois(3e5, 5), ncol=300), sparse = TRUE)
tpm <- Matrix::t(1e6*Matrix::t(tpm)/Matrix::colSums(tpm))
colnames(counts) <- paste0("cell-",rep(1:300))
colnames(tpm) <- paste0("cell-",rep(1:300))
rownames(counts) <- paste0("gene-",rep(1:1000))
rownames(tpm) <- paste0("gene-",rep(1:1000))
annotation <- data.frame("ID"=paste0("cell-",rep(1:300)),
"cell_type"=c(rep("T cells CD4",50),
rep("T cells CD8",50),
rep("Macrophages",100),
rep("NK cells",10),
rep("B cells",70),
rep("Monocytes",20)),
row.names = paste0("cell-",rep(1:300)))
seurat_obj <- Seurat::CreateSeuratObject(counts = counts, assay = 'counts', meta.data = annotation)
tpm_assay <- Seurat::CreateAssayObject(counts = tpm)
seurat_obj[['tpm']] <- tpm_assay
seurat_obj
ds_seurat <- SimBu::dataset_seurat(seurat_obj = seurat_obj,
count_assay = "counts",
cell_id_col = 'ID',
cell_type_col = 'cell_type',
tpm_assay = 'tpm',
name = "seurat_dataset")
# example h5ad file, where cell type info is stored in `obs` layer
h5 <- system.file('extdata', 'anndata.h5ad', package='SimBu')
ds_h5ad <- SimBu::dataset_h5ad(h5ad_file_counts = h5,
name = "h5ad_dataset",
cell_id_col = 'ID',                  # this will use the 'ID' column of the metadata as cell identifiers
cell_type_col = 'cell_type',         # this will use the 'cell_type' column of the metadata as cell type info
cells_in_obs = TRUE)                 # in case your cell information is stored in the var layer, switch to FALSE
pkgdown::build_article('simulator_input_output')
debugSource("~/omnideconv/test.R")
debugSource("~/omnideconv/test.R")
?path_ext
path
path <- tryCatch(callr::r_safe(function(...) rmarkdown::render(...),
args = args, show = !quiet, env = c(callr::rcmd_safe_env(),
BSTINPUTS = bst_paths(input_path), TEXINPUTS = tex_paths(input_path),
BIBINPUTS = bib_paths(input_path), R_CLI_NUM_COLORS = 256)),
error = function(cnd) {
rule("RMarkdown error")
cat(gsub("\r", "", cnd$stderr, fixed = TRUE))
rule()
abort("Failed to render RMarkdown", parent = cnd)
})
callr::r_safe(function(...) rmarkdown::render(...),
args = args, show = !quiet, env = c(callr::rcmd_safe_env(),
BSTINPUTS = bst_paths(input_path), TEXINPUTS = tex_paths(input_path),
BIBINPUTS = bib_paths(input_path), R_CLI_NUM_COLORS = 256))
pkgdown::build_article('simulator_input_output')
pkgdown::build_article('simulator_input_output')
pkgdown::build_article('simulator_input_output')
pkgdown::build_article('simulator_input_output')
pkgdown::build_article('sfaira_vignette')
pkgdown::build_article('sfaira_vignette')
pkgdown::build_article('sfaira_vignette',lazy = F)
?pkgdown::build_article('sfaira_vignette',lazy = F)
?pkgdown::as_pkgdown()
pkgdown::as_pkgdown()
pkg<-pkgdown::as_pkgdown()
View(pkg)
pkgdown::build_articles_index(pkg)
?pkgdown::build_articles_index(pkg)
pkgdown::build_article('simulator_input_output')
pkgdown::build_article('simulator_input_output')
pkgdown::build_article('simulator_input_output')
library(pkgdown)
build_articles_index(pkg)
pkg<-pkgdown::as_pkgdown()
pkg<-pkgdown::as_pkgdown()
purrr::walk(
pkg$vignettes$name, pkgdown::build_article,
pkg = pkg,
quiet = T,
lazy = T
)
name <- 'sfaira_vignette'
vig <- match(name, pkg$vignettes$name)
input <- pkg$vignettes$file_in[vig]
output_file <- pkg$vignettes$file_out[vig]
depth <- pkg$vignettes$depth[vig]
input_path <- path_abs(input, pkg$src_path)
output_path <- path_abs(output_file, pkg$dst_path)
?path_abs
library(fs)
input <- pkg$vignettes$file_in[vig]
output_file <- pkg$vignettes$file_out[vig]
depth <- pkg$vignettes$depth[vig]
input_path <- path_abs(input, pkg$src_path)
output_path <- path_abs(output_file, pkg$dst_path)
input_path
output_path
local_envvar_pkgdown(pkg)
withr::local_envvar(
IN_PKGDOWN = "true",
LANGUAGE = pkg$lang,
.local_envir = parent.frame()
)
local_options_link <- function(pkg, depth, .frame = parent.frame()) {
article_index <- article_index(pkg)
Rdname <- get_rdname(pkg$topics)
topic_index <- unlist(invert_index(set_names(pkg$topics$alias, Rdname)))
withr::local_options(
list(
downlit.package = pkg$package,
downlit.article_index = article_index,
downlit.topic_index = topic_index,
downlit.article_path = paste0(up_path(depth), "articles/"),
downlit.topic_path = paste0(up_path(depth), "reference/")
),
.local_envir = .frame
)
}
pkg$vignettes$depth
local_options_link(pkg, depth = 1)
article_index <- function(pkg) {
set_names(
fs::path_rel(pkg$vignettes$file_out, "articles"),
path_file(pkg$vignettes$name)
)
}
local_options_link(pkg, depth = 1)
?setNames
?set_names
librray(purrr)
render_rmarkdown(
pkg,
input = input,
output = output_file,
output_format = format,
output_options = options,
quiet = quiet
)render_rmarkdown <- function(pkg, input, output, ..., copy_images = TRUE, quiet = TRUE) {
input_path <- path_abs(input, pkg$src_path)
output_path <- path_abs(output, pkg$dst_path)
if (!file_exists(input_path)) {
stop("Can't find ", src_path(input), call. = FALSE)
}
cat_line("Reading ", src_path(input))
digest <- file_digest(output_path)
args <- list(
input = input_path,
output_file = path_file(output_path),
output_dir = path_dir(output_path),
intermediates_dir = tempdir(),
encoding = "UTF-8",
envir = globalenv(),
...,
quiet = quiet
)
path <- tryCatch(
callr::r_safe(
function(...) rmarkdown::render(...),
args = args,
show = !quiet,
env = c(
callr::rcmd_safe_env(),
BSTINPUTS = bst_paths(input_path),
TEXINPUTS = tex_paths(input_path),
BIBINPUTS = bib_paths(input_path),
R_CLI_NUM_COLORS = 256
)
),
error = function(cnd) {
rule("RMarkdown error")
cat(gsub("\r", "", cnd$stderr, fixed = TRUE))
rule()
abort("Failed to render RMarkdown", parent = cnd)
}
)
if (identical(path_ext(path)[[1]], "html")) {
update_html(
path,
tweak_rmarkdown_html,
input_path = path_dir(input_path),
pkg = pkg
)
}
if (digest != file_digest(output_path)) {
cat_line("Writing ", dst_path(output))
}
# Copy over images needed by the document
if (copy_images) {
ext_src <- rmarkdown::find_external_resources(input_path)
# temporarily copy the rendered html into the input path directory and scan
# again for additional external resources that may be been included by R code
tempfile_in_input_dir <- file_temp(ext = "html", tmp_dir = path_dir(input_path))
file_copy(path, tempfile_in_input_dir)
withr::defer(unlink(tempfile_in_input_dir))
ext_post <- rmarkdown::find_external_resources(tempfile_in_input_dir)
ext <- rbind(ext_src, ext_post)
ext <- ext[!duplicated(ext$path), ]
# copy web + explicit files beneath vignettes/
is_child <- path_has_parent(ext$path, ".")
ext_path <- ext$path[(ext$web | ext$explicit) & is_child]
src <- path(path_dir(input_path), ext_path)
dst <- path(path_dir(output_path), ext_path)
# Make sure destination paths exist before copying files there
dir_create(unique(path_dir(dst)))
file_copy(src, dst, overwrite = TRUE)
}
check_missing_images(pkg, input, output)
invisible(path)
}
render_rmarkdown <- function(pkg, input, output, ..., copy_images = TRUE, quiet = TRUE) {
input_path <- path_abs(input, pkg$src_path)
output_path <- path_abs(output, pkg$dst_path)
if (!file_exists(input_path)) {
stop("Can't find ", src_path(input), call. = FALSE)
}
cat_line("Reading ", src_path(input))
digest <- file_digest(output_path)
args <- list(
input = input_path,
output_file = path_file(output_path),
output_dir = path_dir(output_path),
intermediates_dir = tempdir(),
encoding = "UTF-8",
envir = globalenv(),
...,
quiet = quiet
)
path <- tryCatch(
callr::r_safe(
function(...) rmarkdown::render(...),
args = args,
show = !quiet,
env = c(
callr::rcmd_safe_env(),
BSTINPUTS = bst_paths(input_path),
TEXINPUTS = tex_paths(input_path),
BIBINPUTS = bib_paths(input_path),
R_CLI_NUM_COLORS = 256
)
),
error = function(cnd) {
rule("RMarkdown error")
cat(gsub("\r", "", cnd$stderr, fixed = TRUE))
rule()
abort("Failed to render RMarkdown", parent = cnd)
}
)
if (identical(path_ext(path)[[1]], "html")) {
update_html(
path,
tweak_rmarkdown_html,
input_path = path_dir(input_path),
pkg = pkg
)
}
if (digest != file_digest(output_path)) {
cat_line("Writing ", dst_path(output))
}
# Copy over images needed by the document
if (copy_images) {
ext_src <- rmarkdown::find_external_resources(input_path)
# temporarily copy the rendered html into the input path directory and scan
# again for additional external resources that may be been included by R code
tempfile_in_input_dir <- file_temp(ext = "html", tmp_dir = path_dir(input_path))
file_copy(path, tempfile_in_input_dir)
withr::defer(unlink(tempfile_in_input_dir))
ext_post <- rmarkdown::find_external_resources(tempfile_in_input_dir)
ext <- rbind(ext_src, ext_post)
ext <- ext[!duplicated(ext$path), ]
# copy web + explicit files beneath vignettes/
is_child <- path_has_parent(ext$path, ".")
ext_path <- ext$path[(ext$web | ext$explicit) & is_child]
src <- path(path_dir(input_path), ext_path)
dst <- path(path_dir(output_path), ext_path)
# Make sure destination paths exist before copying files there
dir_create(unique(path_dir(dst)))
file_copy(src, dst, overwrite = TRUE)
}
check_missing_images(pkg, input, output)
invisible(path)
}
render_rmarkdown(
pkg,
input = input,
output = output_file,
quiet = T
)
library(pkgdown)
build_articles()
library(SimBu)
library(ggplot2)
# example h5ad file, where cell type info is stored in `obs` layer
h5_rev <- system.file('extdata', 'anndata_rev.h5ad', package='SimBu')
proc <- basilisk::basiliskStart(SimBu_env)
# dependencies for sfaira and anndata0.7.6 (taken from zellkonverter package)
SimBu_env <- basilisk::BasiliskEnvironment(envname="SimBu_env_0_99_0",
pkgname="SimBu",
packages=c('python==3.9',
"anndata==0.7.6",
"h5py==3.2.1",
"hdf5==1.10.6",
"natsort==7.1.1",
"numpy==1.20.2",
"packaging==20.9",
"pandas==1.2.4",
"scipy==1.6.3",
"sqlite==3.35.5"),
pip = c('sfaira==0.3.12',
'tables==3.7.0')
)
proc <- basilisk::basiliskStart(SimBu_env)
h5ad_data <- basilisk::basiliskRun(proc, function(h5ad_path){
sp <- reticulate::import("scanpy")
adata <- sp$read_h5ad(h5ad_path)
return(adata$X)
},h5ad_path=h5)
h5ad_data <- basilisk::basiliskRun(proc, function(h5ad_path){
sp <- reticulate::import("scanpy")
adata <- sp$read_h5ad(h5ad_path)
return(adata$X)
},h5ad_path=h5_rev)
ds_h5ad <- SimBu::dataset_h5ad(h5ad_file_counts = h5_rev,
name = "h5ad_dataset",
cell_id_col = 'ID',                  # this will use the 'ID' column of the metadata as cell identifiers
cell_type_col = 'cell_type',         # this will use the 'cell_type' column of the metadata as cell type info
cells_in_obs = FALSE)                 # in case your cell information is stored in the var layer, switch to FALSE
pkgdown::build_article('simulator_input_output')
pkgdown::build_article('sfaira_vignette')
pkgdown::build_articles('../SimBu')
pkgdown::build_site()
BiocCheck::BiocCheck()
BiocCheck::BiocCheck()
BiocCheck::BiocCheck()
knitr::knit("vignettes/sfaira_vignette.Rmd.orig", output = "vignettes/sfaira_vignette.Rmd")
knitr::knit("vignettes/simulator_documentation.Rmd.orig", output = "vignettes/simulator_documentation.Rmd")
knitr::knit("vignettes/simulator_input_output.Rmd.orig", output = "vignettes/simulator_input_output.Rmd")
knitr::knit("vignettes/simulator_scaling_factors.Rmd.orig", output = "vignettes/simulator_scaling_factors.Rmd")
pkgdown::build_site()
pkgdown::build_site()
![plot of chunk unnamed-chunk-9](man/figures/unnamed-chunk-9-1.png)
pkgdown::build_site()
pkgdown::build_site()
rpois
?rpois
pkgdown::build_site()
devtools::document()
pkgdown::build_site()
devtools::document()
devtools::document()
pkgdown::build_site()
pkgdown::build_site()
devtools::document()
pkgdown::build_site()
