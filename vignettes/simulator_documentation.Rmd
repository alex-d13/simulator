---
title: "Getting started with the pseudo-bulk simulator R package"
author: "Alexander Dietrich"
bibliography: references.bib
biblio-style: apalike
link-citations: yes
colorlinks: yes
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simulator_documentation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Installation

To install the package, run this:
(Since it is a private repository, you currently need an authentication token for this repository.)

```{r, eval=FALSE}
install.packages("devtools")
devtools::install_github("omnideconv/simulator") #add auth_token=XXX to download from private repository
```


```{r setup}
library(SimBu)
library(data.table)
library(tidyr)
library(Matrix)
library(Seurat)
library(ggplot2)
library(RColorBrewer)
```

# Introduction
Cell-type deconvolution is an important analysis-step while processing bulk RNA-seq experiments 
and many tools exist to tackle this issue. Though the user lacks a good comparison between those
tools and when one might be more beneficial than others. \
The goal of SimBu is to create benchmark datasets, where pseudo bulk samples with 
predefined cell-type fractions can be simulated using expression data from single-cell RNAseq
experiments. 

# Getting started

This chapter covers all you need to know to quickly simulate some pseudo-bulk samples!

## Setup the simulator
This package can simulate samples from local or public data. We will start with the public data
integration, since it requires mostly no manual download of datasets. As a public database, 
sfaira [@Fischer2020] is used, which is a dataset and model repository for single-cell RNA-sequencing
data. It gives access to about 233 datasets from human and mouse with more than 3 million cells in total. 
You can browse them interactively here: [https://theislab.github.io/sfaira-portal/Datasets](https://theislab.github.io/sfaira-portal/Datasets). Note 
that only annotated datasets will be downloaded! \
In order to use this database, we first need to install it. We recommend to use [conda](https://docs.conda.io/projects/conda/en/latest/index.html) to create a new
environment and install sfaira into this directory. This ensures that no other packages interfere with the installation. \
*Note:* currently the simulator seems to work only with the develop version of sfaira.\
A recommended step by step installation would look like this:
```
conda create --name sfaira python=3.9 pip
conda activate sfaira
/path/to/conda/envs/sfaira/bin/pip install git+https://github.com/theislab/sfaira.git@dev #this ensures that the correct pip is used
```
Watch out that you are using pip inside of the new environment, not the global pip!\

You do not need to activate the new conda environment each time in order to use it in the R package.\
To setup sfaira inside of the R package use this command: 

```{r, warning=TRUE, message=TRUE}
setup_list <- SimBu::setup_sfaira(python_path = "/nfs/home/students/adietrich/.conda/envs/sfaira/bin/python3",
                                      env_name = "sfaira", 
                                      basedir = "/nfs/home/students/adietrich/ma/data/sfaira")
```

The `python_path` parameter is used to set the path to the python executable **inside** of the
newly created conda environment. Similarly, the `env_name` parameter is the name of this newly
created conda environment. These two parameters need to be set correctly, so that sfaira can be
used later on. You can find out the python-path in a conda environment named `sfaira` like this:\
```
activate sfaira
which python3
```

The third parameter describes the name of a directory in which the raw files, meta data and cached
data from downloading datasets from sfaira are stored into. \
You need to save the output of the command above in a variable for later use. \
If you do not wish to use sfaira, just skip this step entirely. 

## Creating a dataset

The simulator package works with two internally defined data-structures: *datasets* and *databases*. \
We will now create a dataset of samples from human pancreas using the `organisms` and `tissues` parameter.
You can provide a single word (like we do here) or for example a list of tissues
you want to download: `c("pancreas","lung")`. An additional parameter is the `assays` parameter,
where you subset the database further to only download datasets from certain sequencing
assays (for examples `Smart-seq2`). \
The `name` parameter is used later on to give each sample a unique name.

```{r, warning=TRUE, message=TRUE}
ds_human_pancreas <- SimBu::dataset_sfaira_multiple(sfaira_setup = setup_list,
                                                        organisms = "human", 
                                                        tissues = "pancreas", 
                                                        name="human_pancreas")
```
Currently there are two datasets in sfaira from human pancreas, which have cell-type annotation.
The package will download them for you automatically and merge them together into a single expression
matrix and a streamlined annotation table, which we can use for our simulation. \
It can happen, that some datasets from sfaira are not (yet) ready for the automatic download,
an error message will then appear in R, telling you which file to download and where to put it. \

If you wish to see all datasets which are included in sfaira you can use the following command:
```{r}
all_datasets <- SimBu::sfaira_overview(setup_list = setup_list)
head(all_datasets)
```


## Simulate pseudo bulk datasets

We are now ready to simulate the first pseudo bulk samples with the created dataset:

```{r}
simulation <- SimBu::simulate_bulk(data = ds_human_pancreas,
                                       scenario = "random", 
                                       scaling_factor = "NONE", 
                                       ncells=1000, 
                                       nsamples = 50, 
                                       ncores = 4)
```

`ncells` sets the number of cells in each sample, while `nsamples` sets the total amount
of simulated samples. \
You can also control the number of cells per sample by using the `total_read_counts`
parameter, which sets the total number of counts per sample. This can be used to simulate different
sequencing depths. If you wish to use this parameter, it is important to know what type of
expression data you have (raw or normalized). If you for example use TPMs as expression values
and set the total read counts to `1e7`, this will get you really huge samples with many cells, since
TPM values are generally smaller than the raw count values. 

Currently there are 6 `scenarios` implemented in the package: \
 
* *random*: for each cell in a sample, the cell-type is chosen randomly. This scenario is 
depending on the background distribution of the cell-types in the created dataset. If for example
your dataset contains 20% B-cells, 40% T-cells and 40% Macrophages, this scenario will create samples
where this distribution is mirrored closely. \

* *uniform*: this creates samples, where all existing cell-types in the dataset appear in 
the same proportions. So using a dataset with 3 cell-types, this will simulate samples, where
all cell-type fractions are 1/3. \

* *spike-in*: here you need to set two additional parameters for the `simulate_bulk()` function:
`spike_in_cell_type` sets the cell-type you want to be over-representing and 
`spike_in_amount` sets the fraction of this cell-type. You could for example use `B-cell` and `0.5`
to create samples, where 50% are B-cells and the rest is filled randomly with other cell-types. \

* *spill-over*: this simulates samples with only a single cell-type present. Like with *spike-in*
you need to set this cell-type with the additional parameter `spillover_cell_type`. \

* *unique*: this creates simulations of only one single cell-type. You have to provide the name
of this cell-type with the `unique_cell_type` parameter. 

* *custom*: here you are able to create your own set of cell-type fractions. When using this scenario,
you additionally need to provide a dataframe in the `custom_scenario_data` parameter, where each row represents
one sample (therefore the number of rows need to match the `nsamples` parameter). Each column has to represent
one cell-type, which also occurs in the dataset and describes the fraction of this cell-type in a sample. The fractions
per sample need to sum up to 1. An example can be seen here:

```{r, format="markdown"}
unique_scenario_dataframe <- data.frame(
  "B cells" = c(0.2, 0.1, 0.5, 0.3),
  "T cells" = c(0.3, 0.8, 0.2, 0.5),
  "NK cells" = c(0.5, 0.1, 0.3, 0.2),
  row.names = c("sample1","sample2","sample3","sample4")
)
unique_scenario_dataframe
```


## Results

The `simulation` object contains three named entries: \

* `pseudo_bulk_raw`: a sparse matrix with - in this case - 50 columns and about 60k rows 
(this is the number of features/genes). This is the simulated expression matrix. \

* `pseudo_bulk`: same as above, but CPM normalized samples. \

* `cell_fractions`: a dataframe with 50 rows and 15 columns (this is the number of cell-types).
It gives the fractions for each cell-type in each sample. \

* `expression_set`: a Biobase [ExpressionSet](https://rdrr.io/bioc/Biobase/man/class.ExpressionSet.html) \

Finally here is a boxplot of the resulting simulation:

```{r, fig.width=8, fig.height=8}
fractions <- simulation$cell_fractions
fractions$sample <- rownames(fractions)
frac_long <- gather(fractions, cell_type, fraction, 1:length(fractions)-1)

ggplot(frac_long, aes(x=fraction, y=sample, fill=cell_type))+
  geom_col()+
  ggtitle("Cell-type fractions for 50 pseudo-bulk RNAseq samples")+
  scale_fill_manual(values = colorRampPalette(brewer.pal(8, "Set2"))(length(unique(frac_long$cell_type))))
```


# More features

## Using your own data

The simulator also has the option to create datasets with your own scRNAseq experiments.
You can create datasets in three different ways: \

* Using a expression matrix & annotation file

```{r}
# change paths accordingly
counts <- Matrix(as.matrix(fread("~/ma/data/Maynard/X_tpm.csv")), sparse = T)
genes <- fread("~/ma/data/Maynard/var.csv")
cells <- fread("~/ma/data/Maynard/obs.csv")
cellnames <- cells$Run
genenames <- genes$symbol
dimnames(counts)<-list(cellnames, genenames)
counts <- t(counts)

annotation <- fread("~/ma/data/Maynard/annotation_obs.csv")[,c("Run","cell_type")]
colnames(annotation) <- c("ID", "cell_type")

dataset_file <- SimBu::dataset(annotation = annotation,
                                   count_matrix = counts,
                                   name="Maynard")
```

* Using a h5ad expression data & annotation file

```{r}
# change paths accordingly
h5ad_file <- "~/ma/data/Travaglini/Travaglini_Krasnow_2020_Lung_SS2.h5ad"
annotation <- fread("~/ma/data/Travaglini/obs_extended.csv")
# renaming the columns
colnames(annotation)[which(colnames(annotation) == "free_annotation")]<-"cell_type"
colnames(annotation)[which(colnames(annotation) == "index")]<-"ID"

dataset_h5ad <- SimBu::dataset_h5ad(annotation = annotation,
                                        h5ad_file = h5ad_file, 
                                        name = "Travaglini")
```


* Using a Seurat Object and annotation file

```{r}
# download Seurat object from tabula muris
# https://figshare.com/ndownloader/files/13088531
load("~/ma/data/tabula_muris/tabula_muris_bladder.Robj")
seurat_obj <- Seurat::UpdateSeuratObject(tiss)
annotation <- seurat_obj@meta.data
# renaming the columns
colnames(annotation)[which(colnames(annotation) == "free_annotation")]<-"cell_type"
annotation$ID <- rownames(annotation)

dataset_seurat <- SimBu::dataset_seurat(annotation = annotation,
                                            seurat_obj = seurat_obj,
                                            name="TabulaMuris_Bladder")
```


**Important:** the annotation dataframe you are feeding into the dataset, needs these two
columns: `ID` for the cell ID, which has to be in common with the cell IDs in the 
expression matrix and `cell_type`, which gives the cell-type for a cell. \

## Simulate using a whitelist (and blacklist) of cell-types

Sometimes, you are only interested in specific cell-types, but the dataset you are using
has way too many cell-types:

```{r}
unique(dataset_file@annotation$cell_type)
length(unique(dataset_file@annotation$cell_type))
```
You can handle this issue during simulation using the `whitelist` parameter:

```{r, fig.width=8, fig.height=8}
simulation <-  SimBu::simulate_bulk(data = dataset_file,
                                        scenario = "spike_in", 
                                        scaling_factor = "NONE", 
                                        spike_in_cell_type = "NK cell",
                                        spike_in_amount = 0.5,
                                        ncells=1000, 
                                        nsamples = 50, 
                                        ncores = 12,
                                        whitelist = c("NK cell","B cell","T cell CD8", "T cell CD4", "Macrophage", "Monocyte conventional", "Monocyte non-conventional"))

fractions <- simulation$cell_fractions
fractions$sample <- rownames(fractions)
frac_long <- gather(fractions, cell_type, fraction, 1:length(fractions)-1)

ggplot(frac_long, aes(x=fraction, y=sample, fill=cell_type))+
  geom_col()+
  ggtitle("Cell-type fractions for 50 pseudo-bulk RNAseq samples")+
  scale_fill_manual(values = colorRampPalette(brewer.pal(8, "Set2"))(length(unique(frac_long$cell_type))))
```

In the same way, you can also provide a `blacklist` parameter, where you name the
cell-types you **don't** want to be included in your simulation.


## Filtering and Aggregation

It is possible to filter your dataset by variance and remove genes with only 0 expression values. Also low expressed cell-types can be removed.

```{r, eval=FALSE}

ds_filtered <- SimBu::dataset(annotation=annotation,
                       count_matrix = count_matrix,
                       name="filter_test", 
                       type_abundance_cutoff=10, 
                       filter_genes = T, 
                       variance_cutoff = .1)

```

Here we removed all cells which belong to a cell-type that has only 10 or less cells annotated with the `type_abundance_cutoff` parameter. \
`filter_genes` will remove all genes which have an expression value of 0 over all cells. \
With `variance_cutoff` you can set a cutoff to remove all genes with a variance over all cells below this value.\

\

The pseudo-bulk sample will be generated by aggregating the expression values from all sampled cells and is then normalized. The default aggregation method is `sum`, but you also have the options `mean` and `median`. You can select them like this:

```{r, eval=FALSE}

sim_aggregation <- SimBu::simulate_bulk(data=ds,
                                 scenario="random",
                                 scaling_factor="NONE",
                                 sample_aggreation = "median",  # use median as aggregation
                                 nsamples = 100, 
                                 ncells=1000,
                                 ncores=4)

```




# References
