---
title: "Inputs & Outputs"
author: "Alexander Dietrich"
bibliography: references.bib
biblio-style: apalike
link-citations: yes
colorlinks: yes
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Inputs & Outputs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(SimBu)
library(Seurat)
```

This chapter covers the different input and output options of the package in detail.

# Input

The input for your simulations is always the custom `dataset` object. You can create this object with different constructing functions, which will explained below. It is also possible to merge multiple `dataset` objects into one. \
Sfaira is not covered in this vignette, but in ["Public Data Integration"](sfaira_vignette.Rmd).\

## Custom data

Using existing count matrices and annotations is already covered in the ["Getting started"](simulator_documentation.Rmd) vignette; this section will explain some minor details.\

When generating a dataset with your own data, you need to provide at least one matrix via either the `count_matrix` or `tpm_matrix` parameter of `dataset()`; for both of them, genes are located in the rows, cells in the columns.\
Additionally, an annotation table is needed, with the cell-type annotations. It needs to consist of at least out of 2 columns: `ID` and `cell_type`, where `ID` has to be identical to the column names of the provides matrix/matrices. If not all cells appear in the annotation or matrix, the intersection of both is used to generate the dataset. \


### Seurat

It is possible to use a Seurat object to build a dataset; you need an additional dataframe for the annotation:

```{r, eval=FALSE}
ds_seurat <- SimBu::dataset_seurat(seurat_obj_counts = seurat_object_counts,
                                   seurat_obj_tpm = seurat_object_tpm,
                                   annotation = annotation,
                                   name = "seurat_dataset")
```

### h5ad files

It is possible to use an h5ad file directly, a file format which stores [AnnData](https://anndata.readthedocs.io/en/latest/) objects; again you need an additional dataframe for the annotation: 

```{r, eval=FALSE}

ds_h5ad <- SimBu::dataset_h5ad(h5ad_file_counts = h5ad_file_counts,
                               h5ad_file_tpm = h5ad_file_tpm,
                               annotation = annotation,
                               name = "h5ad_dataset")

```

## Merging datasets

You are able to merge multiple datasets by using the `dataset_merge` function:

```{r, eval=FALSE}

ds_multiple <- SimBu::dataset_merge(dataset_list = list(ds_1, ds_2, ds_3),
                                    name = "ds_multiple")

```


# Simulations
Once a dataset is generated, you can use `simulate_bulk` to generate pseudo-bulk samples, resulting in an artificial RNA-seq dataset. \
Similar to datasets, it is also possible to merge simulations:

```{r, eval=FALSE}
merged_simulations <- SimBu::merge_simulations(list(sim_1, sim_2, sim_3))
```



# Output


The `simulation` object contains three named entries: \

* `bulk`: a SummarizedExperiment object with the pseudo-bulk dataset(s) stored in the `assays`. They can be accessed like this:

```{r, eval=FALSE}
assays(simulation$bulk)[["bulk_counts"]]
assays(simulation$bulk)[["bulk_tpm"]]
```

If only a single matrix was given to the dataset initially, only one assay is filled.

* `cell_fractions`: a table where rows represent the simulated samples and columns represent the different simulated cell-types. The entries in the table store the specific cell-type fraction per sample.\

* `scaling_vector`: a named list, with the used scaling value for each cell from the single cell dataset. \
